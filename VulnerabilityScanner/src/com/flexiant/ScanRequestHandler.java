package com.flexiant;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.net.Socket;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.concurrent.ArrayBlockingQueue;

import javax.crypto.Cipher;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SealedObject;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

import org.apache.log4j.Level;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;

/**
 * Class to handle the socket requests. This class reads from the socket and
 * adds to the queue.
 * 
 * @author mramannavar
 *
 */
public class ScanRequestHandler implements Runnable {

	Socket socket = null;
	ArrayBlockingQueue<Request> queue = null;
	private static Logger LOGGER = LogManager.getLogger(ScanRequestHandler.class);
	Clouds cloud;

	public ScanRequestHandler(Socket socket, ArrayBlockingQueue<Request> queue, Clouds cloud) {
		this.socket = socket;
		this.queue = queue;
		this.cloud = cloud;
	}

//	private ArrayList<String> readInput(InputStream input) {
//
//		ArrayList<String> arguments = new ArrayList<String>();
//		BufferedReader r = new BufferedReader(new InputStreamReader(input));
//		try {
//			String lineRead = r.readLine();
//			String[] args = lineRead.split(" ");
//
//			for (int i = 0; i < args.length; i++) {
//				LOGGER.info("Arg " + i + ": " + args[i]);
//				arguments.add(args[i]);
//			}
//		} catch (Exception e) {
//			e.printStackTrace();
//		}
//		return arguments;
//	}

	public static VMDetails decryptSealedVMObject(SealedObject sealedDetails) throws Exception {
		//try {

			SecretKey key64 = new SecretKeySpec(new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07 },
					"Blowfish");
			Cipher cipher = Cipher.getInstance("Blowfish");
			cipher.init(Cipher.DECRYPT_MODE, key64);
			VMDetails details = (VMDetails) sealedDetails.getObject(cipher);
			return details;
		//}
//		catch (Exception e) {
//
//			LOGGER.log(Level.FATAL, "Error - Unable to decrypt object");
//			return null;
//		}
	}
	
	public static KeyDetails decryptSealedKeyObject(SealedObject sealedDetails) throws Exception {
		//try {
			SecretKey key64 = new SecretKeySpec(new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07 },
					"Blowfish");
			Cipher cipher = Cipher.getInstance("Blowfish");
			cipher.init(Cipher.DECRYPT_MODE, key64);
			KeyDetails details = (KeyDetails) sealedDetails.getObject(cipher);
			return details;
		//}
//		catch (Exception e) {
//
//			LOGGER.log(Level.FATAL, "Error - Unable to decrypt object");
//			return null;
//		}
	}

	@Override
	public void run() {
		try {
			LOGGER.log(Level.INFO, "Adding a request to the queue...");
			ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
			VMDetails details;
			VMDetails detailsRaw = null;
			KeyDetails keyDetailsRaw = null;
			boolean objectRead = false;
			
			Object obj = ois.readObject();

			//First try parsing request as encrypted VM details
			try {
				SealedObject sealedDetails = (SealedObject) obj;
				detailsRaw = decryptSealedVMObject(sealedDetails);
				LOGGER.log(Level.INFO, "Decryption of details successful");
				objectRead = true;
			}

			catch (Exception ex1) {
				LOGGER.log(Level.WARN, "Decryption of object failed");
			}

			if (objectRead == false) {
				//Next try parsing request as unencrypted VM details
				try {
					detailsRaw = (VMDetails) obj;
					LOGGER.log(Level.INFO, "Unencrypted object successfully read");
					objectRead = true;
				}

				catch (Exception ex2) {
					LOGGER.log(Level.WARN, "Object unable to be parsed as VMDetails");
				}
			}
			
			if(objectRead == false){

				try{
					SealedObject sealedDetails = (SealedObject) obj;
					keyDetailsRaw = decryptSealedKeyObject(sealedDetails);
					LOGGER.log(Level.INFO, "Decryption of details as firewall key details successful");
					
					LOGGER.log(Level.INFO, "Key I.P: " + keyDetailsRaw.getServerIP());
					LOGGER.log(Level.INFO, "Key : " + keyDetailsRaw.getKey());
					
					FirewallRequests.firewallRequests.put(keyDetailsRaw.getServerIP(), keyDetailsRaw.getKey());
					
					LOGGER.log(Level.INFO, "Hashmap size: " + FirewallRequests.firewallRequests.size());
					
				}
				catch(Exception ex3){
					LOGGER.log(Level.FATAL, "Object unable to be parsed");
				}
			}

			if (objectRead) {
				String serverUUID = detailsRaw.getServerUUID();
				String serverIP = detailsRaw.getIP();
				String emailID = detailsRaw.getEmailID();
				String username = detailsRaw.getUsername();
				String password = detailsRaw.getPassword();

				LOGGER.info("Input UUID " + serverUUID);
				LOGGER.info("Input Server I.P. " + serverIP);
				LOGGER.info("Input email address " + emailID);
				LOGGER.info("Input username: " + username);
				LOGGER.info("Input password: " + password);

				details = new VMDetails(serverUUID, serverIP, emailID, username, password);
				Request request = new Request(details);
				request.setCloud(cloud);

				// The ArrayBlockingQueue is thread safe
				queue.add(request);
			}
			
			else{
				
				LOGGER.log(Level.FATAL,"Scan aborted, no object received");
			}
		} catch (IOException e) {
			LOGGER.error("Failed to read data from the Socket", e);
		} catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}
